// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
RWStructuredBuffer<int> Permutation;
int PermutationLength;
float GridSize;

float2 normalize(float2 position) 
{
    float hypotenuse = sqrt(position.x * position.x + position.y * position.y);
    float normalizedX = position.x / hypotenuse;
    float normalizedY = position.y / hypotenuse;

    return float2(normalizedX, normalizedY);
}

float dotproduct(float2 pos1, float2 pos2) 
{
    float2 norm1 = pos1;
    float2 norm2 = pos2;

    return norm1.x * norm2.x + norm1.y * norm2.y;
}

float interpolate(float point1, float point2, float weight) 
{
    return (point2 - point1) * weight + point1;
}

float2 randomVector(float2 position) 
{
    float randomValue = (float)Permutation[(int)((round(position.x) + round(position.y)) / PermutationLength)];
    float noiseX = (frac(sin(dot(position, float2(12.9898, 78.233)) + randomValue) * 43758.5453));
    float noiseY = (frac(sin(dot(position, float2(12.9898, 78.233) * 2.0) + randomValue) * 43758.5453));
    
    return normalize(float2(noiseX - 0.5f, noiseY - 0.5f));
}

float perlin(float2 uv) 
{
    float2 position = float2(uv.x / GridSize, uv.y / GridSize);
    float2 floorPosition = float2((float)floor(position.x), (float)floor(position.y));
    float2 gridPosition = float2(position.x - (float)round(position.x), position.y - (float)round(position.y));

    float weightX = position.x - floorPosition.x;

    float dot1 = dotproduct(gridPosition, randomVector(floorPosition));
    float dot2 = dotproduct(gridPosition, randomVector(float2(floorPosition.x + 1, floorPosition.y)));
    float interpol1 = interpolate(dot1, dot2, weightX);

    dot1 = dotproduct(gridPosition, randomVector(float2(floorPosition.x, floorPosition.y + 1)));
    dot2 = dotproduct(gridPosition, randomVector(float2(floorPosition.x + 1, floorPosition.y + 1)));
    float interpol2 = interpolate(dot1, dot2, weightX);

    return interpolate(interpol1, interpol2, position.y - floorPosition.y);

    //return dotproduct(float2(position.x - (float)round(position.x), position.y - (float)round(position.y)), randomVector(float2((float)round(position.x), (float)round(position.y))));
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!

    float2 position = float2(round(id.x / GridSize), round(id.y / GridSize));

    float value = perlin(id.xy);

    //Result[id.xy] = float4(perlin(id.xy), randomVector(position).x, randomVector(position).y, 0.0f);
    Result[id.xy] = float4(value, value, value, 0.0f);
}
