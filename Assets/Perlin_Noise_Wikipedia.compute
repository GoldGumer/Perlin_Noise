// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
RWStructuredBuffer<int> Permutation;
int PermutationLength;
float GridSize;

float interpolate(float pointOne, float pointTwo, float weight) {
    //You may want clamping by inserting:
    //if (0.0 > w) return pointOne;
    //if (1.0 < w) return pointTwo;

    return (pointTwo - pointOne) * weight + pointOne;

    //Use this cubic interpolation [[Smoothstep]] instead, for a smooth appearance:
    //return (pointTwo - pointOne) * (3.0 - weight * 2.0) * weight * weight + pointOne;

    //Use [[Smootherstep]] for an even smoother result with a second derivative equal to zero on boundaries:
    //return (pointTwo - pointOne) * ((weight * (weight * 6.0f - 15.0f) + 10.0f) * weight * weight * weight) + pointOne;
}

float2 normalize(float2 position)
{
    float hypotenuse = sqrt(position.x * position.x + position.y * position.y);
    float normalizedX = position.x / hypotenuse;
    float normalizedY = position.y / hypotenuse;

    return float2(normalizedX, normalizedY);
}

float2 random(float2 position)
{
    float randomValue = (float)Permutation[(int)((round(position.x) + round(position.y)) / PermutationLength)];
    float noiseX = (frac(sin(dot(position, float2(12.9898, 78.233)) + randomValue) * 43758.5453));
    float noiseY = (frac(sin(dot(position, float2(12.9898, 78.233) * 2.0) + randomValue) * 43758.5453));

    return normalize(float2(noiseX - 0.5f, noiseY - 0.5f));
}

float dotGridGradient(int floorX, int floorY, float x, float y)
{
    float2 xy = { floorX,floorY };
    float2 rand = random(xy);

    float dx = x - (float)floorX;
    float dy = y - (float)floorY;

    return ((rand.x * dx + rand.y * dy) + 1) / 2;
}

float perlin(float2 uv)
{
    int floorX = (int)floor(uv.x);
    int floorXPlusOne = floorX + 1;
    int floorY = (int)floor(uv.y);
    int floorYPlusOne = floorY + 1;

    //detirmines distance to interpolate
    float xWeight = uv.x - (float)floorX;
    float yWeight = uv.y - (float)floorY;

    //interpolates grid point and gradients

    float pointOne, pointTwo, intpolOne, intpolTwo, value;

    pointOne = dotGridGradient(floorX, floorY, uv.x, uv.y);
    pointTwo = dotGridGradient(floorXPlusOne, floorY, uv.x, uv.y);
    intpolOne = interpolate(pointOne, pointTwo, xWeight);

    pointOne = dotGridGradient(floorX, floorYPlusOne, uv.x, uv.y);
    pointTwo = dotGridGradient(floorXPlusOne, floorYPlusOne, uv.x, uv.y);
    intpolTwo = interpolate(pointOne, pointTwo, xWeight);

    value = interpolate(intpolOne, intpolTwo, yWeight);

    return value;
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    float2 uv = { id.x / GridSize,id.y / GridSize };
    float perlinVal = perlin(uv.xy);

    float value = perlinVal;

    Result[id.xy] = float4(value, value, value, 0.0f);
}